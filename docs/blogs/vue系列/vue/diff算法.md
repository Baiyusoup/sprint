---
title: diff算法
date: 2021-07-21
categories: 
 - vue系列
---

## 作用
diff算法的核心在于在尽可能小变动的前提下找到需要更新的节点，直接调用原生相关DOM方法修改视图。算法比较节点不同时，只会进行同层节点的比较，不会跨层进行比较，这也大大减少了算法复杂度。

## 原理
首先第一步是比较新旧节点，如果新旧节点不是同一个节点，那么直接用新节点替换掉旧节，不需要进行下一不的比较了。

第二步是判断新节点是不是文本节点，如果是文本节点的话，再判断新旧节点的text是否一样，不一样的话，就把新节点的文本内容替换掉旧节点。如果新节点不是文本节点的话，就进行第三步。

第三步是判断新旧节点有没有子节点。如果这两个一个有，一个没有的话，基本都是旧节点被删除掉或者被替换掉。

第四步是新旧节点都有子节点。处理新旧子节点的操作是：
1. 进入一个循环
2. 然后根据得到的四个指针开始依次处理新旧节点的children
   1. 首先是比较新前和旧前指向的节点，如果这两个节点相同的话，就进行递归比对，就是回到第一步那里。递归结束后，这两个指针都向右移动一位。就++。
   2. 比较新后与旧后指向的节点，如果这两个相同的话，做法和1是一样的，只不过递归结束后，这两个指针都是向左移动一位(--)。
   3. 比较新后与旧前指向的节点，如果相同的话，也是先递归处理，递归结束后，将旧前指针指向的节点移到尾部，然后旧前指针右移一位，新后指针左移一位。
   4. 比较新前与旧后指向的节点，如果相同，旧递归处理，递归结束后，将旧后指针指向的节点移动到头部，旧后指针左移一位，新前指针右一位
   5. 如果这四种情况没出现的话，就会搜索旧节点的所有子节点，找到将这个旧节点和新前指针指向的节点进行递归处理。不断对比的过程使得oldStartIndex不断逼近oldEndIndex，newStartIndex不断逼近newEndIndex。当oldEndIndex <= oldStartIndex说明旧节点已经遍历完了，此时只要批量增加新节点即可。当newEndIndex <= newStartIndex说明旧节点还有剩下，此时只要批量删除旧节点即可。