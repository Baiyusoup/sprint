(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{567:function(t,a,r){"use strict";r.r(a);var s=r(6),e=Object(s.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"概述"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),r("p",[t._v("闭包指的是那些引用了另一个函数作用域中变量的函数。")]),t._v(" "),r("p",[t._v("在调用一个函数的时候，会为这个函数调用创建一个执行上下文，并创建一个作用域链，然后用arguments和其他命名参数来初始化这个函数的活动对象。这个活动对象会在函数执行期间存在，但是闭包是定义函数内部的函数，因此在这个内部函数作用链上保存着所有它父执行上下的变量对象。将这个内部函数作为返回值后，外部函数虽然执行完了，但是它的变量对象并没有被销毁，我们依然可以通过闭包函数的作用域链找到。")]),t._v(" "),r("p",[t._v("函数内部的代码在访问变量的时候，会使用给定的名称从作用域链中查找变量。所以闭包函数因此能够访问它定义时的外部函数里面的变量。")]),t._v(" "),r("p",[t._v("在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。")]),t._v(" "),r("h2",{attrs:{id:"应用场景"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[t._v("#")]),t._v(" 应用场景")]),t._v(" "),r("p",[t._v("闭包的作用是可以读取函数内部的变量，并让那些变量始终保持在内存中。")]),t._v(" "),r("ol",[r("li",[r("RouterLink",{attrs:{to:"/blogs/手写系列/高阶函数.html"}},[t._v("柯里化")])],1),t._v(" "),r("li",[r("RouterLink",{attrs:{to:"/blogs/JavaScript/ES6/模块.html"}},[t._v("模块化")])],1)])])}),[],!1,null,null,null);a.default=e.exports}}]);