(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{626:function(t,v,_){"use strict";_.r(v);var a=_(6),e=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"重排-回流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#重排-回流"}},[t._v("#")]),t._v(" 重排/回流")]),t._v(" "),_("p",[t._v("当DOM的变化影响到元素的几何信息时，浏览器需要重新计算浏览器的几何信息，将其放在页面上正确的位置，这个过程就叫做重排。简单来说就是重新布局、重新排列元素。")]),t._v(" "),_("h4",{attrs:{id:"发生的时机"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#发生的时机"}},[t._v("#")]),t._v(" 发生的时机")]),t._v(" "),_("ol",[_("li",[t._v("页面初始渲染")]),t._v(" "),_("li",[t._v("添加或删除可见的DOM")]),t._v(" "),_("li",[t._v("改变元素的位置、大小、内容、字体")]),t._v(" "),_("li",[t._v("修改元素style属性的值")]),t._v(" "),_("li",[t._v("激活css伪类，比如"),_("code",[t._v(":hover")])]),t._v(" "),_("li",[t._v("改变浏览器窗口的尺寸")]),t._v(" "),_("li",[t._v("查询元素的几何属性，比如"),_("code",[t._v("offsetWidth")])]),t._v(" "),_("li",[t._v("调用某些计算方法，比如"),_("code",[t._v("getComputedStyle")])])]),t._v(" "),_("h2",{attrs:{id:"重绘"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#重绘"}},[t._v("#")]),t._v(" 重绘")]),t._v(" "),_("p",[t._v("元素的外观发生变化，但没有改变元素的布局，这时候浏览器只需要重新渲染的它的外观即可，这个过程就是重绘。")]),t._v(" "),_("h2",{attrs:{id:"区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[t._v("#")]),t._v(" 区别")]),t._v(" "),_("p",[t._v("重排一定会引起重绘，重绘不一定会引起重排，因此重排的代价比重绘要大。")]),t._v(" "),_("h2",{attrs:{id:"优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优化"}},[t._v("#")]),t._v(" 优化")]),t._v(" "),_("ol",[_("li",[t._v("修改样式时使用className、style.cssText修改，不要一条一条的修改")]),t._v(" "),_("li",[t._v("在对DOM进行负责操作的时候，先把它隐藏起来（"),_("code",[t._v("display:node")]),t._v("），当操作完了再显示")]),t._v(" "),_("li",[t._v("获取并操作那些会引起浏览器回流的属性时，应该先用变量缓存起来，再操作。")]),t._v(" "),_("li",[t._v("不使用table布局，因此在table布局中，有点变化就可能引起整个table的重新布局。")]),t._v(" "),_("li",[t._v("添加大量dom时，可以先添加到文档片段"),_("code",[t._v("DocumentFragment")]),t._v("，完事后才将文档片段添加到DOM树上")])])])}),[],!1,null,null,null);v.default=e.exports}}]);