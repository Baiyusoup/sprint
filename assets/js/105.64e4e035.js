(window.webpackJsonp=window.webpackJsonp||[]).push([[105],{623:function(t,l,v){"use strict";v.r(l);var _=v(6),o=Object(_.a)({},(function(){var t=this,l=t.$createElement,v=t._self._c||l;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"原因"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#原因"}},[t._v("#")]),t._v(" 原因")]),t._v(" "),v("p",[t._v("浏览器有一个同源策略（指同一个协议、同一个域、同一个端口），如果违反了同源策略，浏览器就会拦截响应。同源策略的限制有如下几点")]),t._v(" "),v("ol",[v("li",[t._v("不能获取和操作对方的dom")]),t._v(" "),v("li",[t._v("不能操作对方的cookie、localStorage、indexDB")]),t._v(" "),v("li",[t._v("限制XMLHttpRequest请求")])]),t._v(" "),v("h2",{attrs:{id:"解决方案"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[t._v("#")]),t._v(" 解决方案")]),t._v(" "),v("h3",{attrs:{id:"跨域资源共享cors"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#跨域资源共享cors"}},[t._v("#")]),t._v(" 跨域资源共享CORS")]),t._v(" "),v("p",[t._v("基本思路是使用自定义的http头部来允许浏览器和服务器相互了解，以确定请求或响应应该成功还是失败。CORS会将请求分为简单请求和非简单请求。")]),t._v(" "),v("p",[t._v("简单请求的特征：")]),t._v(" "),v("ol",[v("li",[t._v("请求方法只能是get、post和head")]),t._v(" "),v("li",[t._v("请求头字段的范围是\n"),v("ol",[v("li",[t._v("Accept字段")]),t._v(" "),v("li",[t._v("Accept-Language")]),t._v(" "),v("li",[t._v("Content-Language")]),t._v(" "),v("li",[t._v("Content-Type\n"),v("ol",[v("li",[t._v("application/x-www-urlencoded")]),t._v(" "),v("li",[t._v("multipart/form-data")]),t._v(" "),v("li",[t._v("text/plain")])])])])])]),t._v(" "),v("p",[t._v("在这个范围之外的请求都是非简单请求。对于简单请求，浏览器会在请求头字段加上Origin字段，说明该请求来自哪个源，便于服务器确定是否为其提供响应，如果服务器决定响应请求，那么就会在响应头字段Access-Control-Allow-Origin写上相同的源，如果这个资源是公开的，就写上 “*”")]),t._v(" "),v("p",[t._v("对于非简单请求，CORS有个预检请求的服务器验证机制，来允许使用自定义头部、其他请求方法以及不同的请求体内容类型。")]),t._v(" "),v("p",[t._v("该验证机制的流程如下：")]),t._v(" "),v("ol",[v("li",[t._v("向服务器发送一个options方法，请求头字段设置为：\n"),v("ol",[v("li",[t._v("Origin：请求的域")]),t._v(" "),v("li",[t._v("host 目标地址")]),t._v(" "),v("li",[t._v("Access-Control-Request-Method：请求要使用的方法")]),t._v(" "),v("li",[t._v("Access-Control-Request-Headers：请求使用的请求头")])])]),t._v(" "),v("li",[t._v("如果服务器允许这类型的请求的话，就会在响应头中写上：\n"),v("ol",[v("li",[t._v("Access-Control-Allow-Origin")]),t._v(" "),v("li",[t._v("Access-Control-Allow-Methods")]),t._v(" "),v("li",[t._v("Access-Control-Max-Age")]),t._v(" "),v("li",[t._v("Access-Control-Allow-Headers")])])]),t._v(" "),v("li",[t._v("浏览器收到响应后，会比对origin字段和响应报文中的Access-Control-Allow-Origin的值，如果origin字段的值不包含在该响应字段中，浏览器就会拦截这个响应。如果包含就会放行。此后的请求只需要向简单请求一样处理。")])]),t._v(" "),v("h3",{attrs:{id:"jsonp"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jsonp"}},[t._v("#")]),t._v(" JSONP")]),t._v(" "),v("p",[t._v("原理是利用script标签的src属性不会有跨域限制的特性。\n使用的方式是在src上写上URL，这个URL有一个参数，比如说callback=xxx。服务器那边在收到这个请求后，会将处理完成的数据拼接到这个xxx里，然后放到响应体中，浏览器在收到响应后会解析请求体，这时候xxx函数就会执行，我们就可以在这个xxx函数拿到响应数据。")]),t._v(" "),v("p",[t._v("缺点是容易收到攻击，在响应中加入恶意的内容；不好确定JSONP请求是否失败。")])])}),[],!1,null,null,null);l.default=o.exports}}]);