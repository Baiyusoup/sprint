(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{551:function(t,v,_){"use strict";_.r(v);var e=_(6),a=Object(e.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"宏观事件循环描述"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#宏观事件循环描述"}},[t._v("#")]),t._v(" 宏观事件循环描述")]),t._v(" "),_("p",[t._v("JavaScript是一门单线程的语言，在同一个时间内它只能做一个件事情。为了提高CPU的效率，JavaScript将所有任务分为同步任务和异步任务。同步任务是指在主线程上排队执行的任务；异步任务则是指不进入主线程，而是进入任务队列的任务，只有任务队列通知了主线程，某个异步任务可以执行了，该异步任务才会进入主线程执行。")]),t._v(" "),_("p",[t._v("当一个脚本第一次执行的时候，JS引擎会解析这段代码，并将里面的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的代码是一个方法，那么JS会向执行栈中添加这个方法的执行上下文，然后进入这个执行上下文继续执行其中的代码。当这个执行上下文的代码执行完毕后，JS会退出这个执行上下文并把这个执行上下文销毁，回到上一个方法的执行环境。这个过程会反复进行直到执行栈中的代码全部执行完毕。这个是同步任务的执行过程。")]),t._v(" "),_("p",[t._v("在这过程中，如果遇到一个异步事件后，会将这个事件挂起，继续执行执行栈中的其他任务。当这个异步事件返回结果后，如果这个异步事件是宏任务类型，JS会将这个事件丢到宏任务队列，如果是微任务类型，JS就会将它丢到微任务队列中。如果当前执行栈中所有的任务都执行完了，主线程就会先去查看微任务队列是否有事件存在，如果存在就依次执行微任务队列中事件对应的回调，直到微任务队列为空，然后再去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈中执行，然后执行其中的同步代码。")]),t._v(" "),_("p",[t._v("整个过程这样反复，就形成了一个循环，这个就是事件循环。")]),t._v(" "),_("h2",{attrs:{id:"宏任务和微任务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#宏任务和微任务"}},[t._v("#")]),t._v(" 宏任务和微任务")]),t._v(" "),_("p",[t._v("异步任务还会分为宏任务和微任务，它们两个的执行优先级不同。因此任务队列页分为宏任务队列和微任务队列。")]),t._v(" "),_("p",[t._v("宏任务主要有")]),t._v(" "),_("ol",[_("li",[t._v("setTimeout")]),t._v(" "),_("li",[t._v("setInterval")]),t._v(" "),_("li",[t._v("postMessage")]),t._v(" "),_("li",[t._v("UI交互事件")])]),t._v(" "),_("p",[t._v("微任务主要有")]),t._v(" "),_("ol",[_("li",[t._v("Promise.then")]),t._v(" "),_("li",[t._v("MutationObserver")]),t._v(" "),_("li",[t._v("setImmediate")])]),t._v(" "),_("p",[t._v("微任务永远再宏任务之前执行！")])])}),[],!1,null,null,null);v.default=a.exports}}]);