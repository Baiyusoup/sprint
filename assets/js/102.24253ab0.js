(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{619:function(e,t,a){"use strict";a.r(t);var r=a(6),i=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"强缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[e._v("#")]),e._v(" 强缓存")]),e._v(" "),a("p",[e._v("浏览器在请求某一个资源的时候，会先获取该资源先前缓存的Header信息，然后根据Header里面的Cache-Control和Expires这两个头字段来判断该资源是否已经过期，如果没有过期，那么浏览器只需要从缓存中获取该资源即可，不需要向服务器发起请求；如果过期的话，就需要向服务器发起请求（协商缓存阶段）")]),e._v(" "),a("p",[e._v("优先级上是Cache-Control高于Expires，原因在于Expires的值是一个绝对时间的字符串，如果客户端时间和服务器时间相差较大，缓存命中与否就不是开发者所期望的。Cache-Control是一个时间段，控制就比较容易")]),e._v(" "),a("ul",[a("li",[e._v("no-cache 每次请求都是协商缓存")]),e._v(" "),a("li",[e._v("no-store 不缓存")]),e._v(" "),a("li",[e._v("private 只有发起请求的浏览器才可以进行缓存")]),e._v(" "),a("li",[e._v("public 请求返回的内容所经过的任何路径都可以进行缓存")]),e._v(" "),a("li",[e._v("max-age")])]),e._v(" "),a("h2",{attrs:{id:"协商缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[e._v("#")]),e._v(" 协商缓存")]),e._v(" "),a("p",[e._v("浏览器向服务器发起Http请求，这个请求会携带第一次请求该资源时所缓存的Header信息，服务端会检测请求中的If-None-Match，这个字段的值是服务端上一次返回的响应头ETag的值，如果这个值与现在服务端保存的ETag一致，那么就只需要返回304状态码和空响应体；如果不一致，就返回新的资源以及新的ETag。")]),e._v(" "),a("p",[e._v("如果If-None-Match不存在，还会检测If-Modified-Since这个头字段的值，这个值是上次请求该资源时响应报文头`Last-Modified的值，服务端会比对这个请求头字段的值和服务端所保存的这个资源的最后修改时间，如果一致，那么就返回304状态码和空的响应体，告诉浏览器可以使用本地缓存的资源。如果不一致，就说明资源已更新了，服务端返回新的资源。")]),e._v(" "),a("p",[e._v("优先级上是If-None-Match高于If-Modified-Since，原因在于Last-Modified的单位值秒，无法体现出毫秒级别的变化。")])])}),[],!1,null,null,null);t.default=i.exports}}]);